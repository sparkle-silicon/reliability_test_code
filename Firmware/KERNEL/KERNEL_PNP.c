/*
 * @Author: Iversu
 * @LastEditors: daweslinyu daowes.ly@qq.com
 * @LastEditTime: 2023-12-22 15:45:37
 * @Description:
 *
 *
 * The following is the Chinese and English copyright notice, encoded as UTF-8.
 * 以下是中文及英文版权同步声明，编码为UTF-8。
 * Copyright has legal effects and violations will be prosecuted.
 * 版权具有法律效力，违反必究。
 *
 * Copyright ©2021-2023 Sparkle Silicon Technology Corp., Ltd. All Rights Reserved.
 * 版权所有 ©2021-2023龙晶石半导体科技（苏州）有限公司
 */
#include "KERNEL_PNP.H"
#include "KERNEL_TIMER.H"
#include "KERNEL_SOC_FUNC.H"
 //-----------------------------------------------------------------------------
 // PNP config send requeset
 //-----------------------------------------------------------------------------
void Config_PNP_Access_Request(void)
{
	unsigned long timeout = PNP_Timeout;
	// send access request and read ready
	PNP_CONFIG = EFIR_2E | EFDR_2F | E2PNP_REQ;
	// judge access request clear or not
	do
	{
		if((PNP_CONFIG & E2PNP_RDY) == 1)
			break; /* OK */
		udelay(1000);
		timeout--;
	}
	while(timeout);
	if(timeout == 0)
		dprint("access request timeout\n");
}
//-----------------------------------------------------------------------------
// PNP config release request
//-----------------------------------------------------------------------------
void Config_PNP_Access_Release(void)
{
	unsigned long timeout = PNP_Timeout;
	// clear access request
	PNP_CONFIG = EFIR_2E | EFDR_2F;
	// judge access request clear or not
	do
	{
		if((PNP_CONFIG & E2PNP_RDY) == 0)
			break; /* OK */
		udelay(1000);
		timeout--;
	}
	while(timeout);
	if(timeout == 0)
		dprint("access request clear timeout\n");
}
//-----------------------------------------------------------------------------
// PNP Config write
// Need send request before write
// and release request after write
//-----------------------------------------------------------------------------
void Config_PNP_Write(BYTE idx, BYTE ldn, BYTE data)
{
	int wdata, rdata;
	int e2pnp_reg_wc;
	unsigned long timeout = PNP_Timeout;
	// send write request and write data
	wdata = ((idx << 24) | (ldn << 16) | E2PNP_WriteREQ | data);
	PNP_CTRL1 = wdata;
	// judge wirte done
	do
	{
		rdata = PNP_CTRL1;
		e2pnp_reg_wc = (rdata & E2PNP_WC);
		if(e2pnp_reg_wc != 0)
			break; /* OK */
		udelay(1000);
		timeout--;
	}
	while(timeout);
	if(timeout == 0)
		dprint("pnp write done timeout\n");
	// clear write requeset
	PNP_CTRL1 &= ~E2PNP_WriteREQ;
}
//-----------------------------------------------------------------------------
// PNP Config read
// Need send request before read
// and release request after read
//-----------------------------------------------------------------------------
void Config_PNP_Read(BYTE idx, BYTE ldn)
{
	int wdata, rdata, pnpdata;
	int e2pnp_reg_rc;
	volatile unsigned int timeout = PNP_Timeout, timeout1 = PNP_Timeout;
	// send read request
	wdata = ((idx << 24) | (ldn << 16) | E2PNP_ReadREQ);
	PNP_CTRL1 = wdata;
	// read data
	do
	{
		rdata = PNP_CTRL1;
		e2pnp_reg_rc = (rdata & E2PNP_RC);
		if(e2pnp_reg_rc != 0)
			break; /* OK */
		udelay(1000);
		timeout--;
	}
	while(timeout);
	if(timeout == 0)
		dprint("pnp read done timeout\n");
	idx = (rdata & 0xff000000) >> 24;
	ldn = (rdata & 0x00ff0000) >> 16;
	pnpdata = rdata & 0x000000ff;
	dprint("idx= %#x, ldn=%#x, read value %#x\n", idx, ldn, pnpdata);
	// clear
	PNP_CTRL1 &= ~E2PNP_ReadREQ;
	do
	{
		rdata = PNP_CTRL1;
		if(((rdata & 0x00000f00) >> 8) == 0xc)
			break;
		udelay(1000);
		timeout1--;
	}
	while(timeout1);
	if(timeout1 == 0)
		dprint("pnp finish timeout\n");
}
//-----------------------------------------------------------------------------
// Clear Logical Device Default IRQ Num
//-----------------------------------------------------------------------------
void Clear_Logical_Device_Default_IRQ_Num(void)
{
	Config_PNP_Write(0x7, 0x1, 0x1);
	Config_PNP_Write(0x70, 0x1, 0x0);
	Config_PNP_Write(0x7, 0x2, 0x2);
	Config_PNP_Write(0x70, 0x2, 0x0);
	Config_PNP_Write(0x7, 0x3, 0x3);
	Config_PNP_Write(0x70, 0x3, 0x0);
	Config_PNP_Write(0x7, 0x4, 0x4);
	Config_PNP_Write(0x70, 0x4, 0x0);
	Config_PNP_Write(0x7, 0x8, 0x8);
	Config_PNP_Write(0x70, 0x8, 0x0);
	Config_PNP_Write(0x7, 0xf, 0xf);
	Config_PNP_Write(0x70, 0xf, 0x0);
	Config_PNP_Write(0x7, 0x10, 0x10);
	Config_PNP_Write(0x70, 0x10, 0x0);
	Config_PNP_Write(0x7, 0x11, 0x11);
	Config_PNP_Write(0x70, 0x11, 0x0);
	Config_PNP_Write(0x7, 0x12, 0x12);
	Config_PNP_Write(0x70, 0x12, 0x0);
	Config_PNP_Write(0x7, 0x13, 0x13);
	Config_PNP_Write(0x70, 0x13, 0x0);
	Config_PNP_Write(0x7, 0x15, 0x15);
	Config_PNP_Write(0x70, 0x15, 0x0);
	Config_PNP_Write(0x7, 0x16, 0x16);
	Config_PNP_Write(0x70, 0x16, 0x0);
	Config_PNP_Write(0x7, 0x17, 0x17);
	Config_PNP_Write(0x70, 0x17, 0x0);
	Config_PNP_Write(0x7, 0x18, 0x18);
	Config_PNP_Write(0x70, 0x18, 0x0);
	Config_PNP_Write(0x7, 0x19, 0x19);
	Config_PNP_Write(0x70, 0x19, 0x0);
	Config_PNP_Write(0x7, 0x1a, 0x1a);
	Config_PNP_Write(0x70, 0x1a, 0x0);
	Config_PNP_Write(0x7, 0x1b, 0x1b);
	Config_PNP_Write(0x70, 0x1b, 0x0);
	Config_PNP_Write(0x7, 0x1c, 0x1c);
	Config_PNP_Write(0x70, 0x1c, 0x0);
	Config_PNP_Write(0x7, 0x1d, 0x1d);
	Config_PNP_Write(0x70, 0x1d, 0x0);
	Config_PNP_Write(0x7, 0x1e, 0x1e);
	Config_PNP_Write(0x70, 0x1e, 0x0);
	Config_PNP_Write(0x7, 0x1f, 0x1f);
	Config_PNP_Write(0x70, 0x1f, 0x0);
}
BYTE Sio_PNP_Table[] =
{
	/*LD:MOUSE*/
	0x07,0x05,0x05, // select ld mouse
	0x70,0x05,0x0c, // select serirq num:12
	0x71,0x05,0x03, // set serirq level/edge
	0x30,0x05,0x01, // enable ld
	/*LD:KEYBOARD*/
	0x07,0x06,0x06, // select ld mouse
	0x61,0x06,0x60, // config io port 60
	0x63,0x06,0x64, // config io port 64
	0x70,0x06,0x01, // select serirq num:1
	0x71,0x06,0x03, // set serirq level/edge
	0x30,0x06,0x01, // enable ld
#if !(KBC_PNP_ONLY_SWITCH)
	/*LD:PM1*/
	0x07,0x11,0x11, // select ld mouse
	0x61,0x11,0x62, // config io port 62
	0x63,0x11,0x66, // config io port 66
	0x70,0x11,0x05, // select serirq num:5
	0x71,0x11,0x03, // set serirq level/edge
	0x30,0x11,0x01, // enable ld
	/*LD:PM2*/
	0x07,0x12,0x12, // select ld mouse
	0x61,0x12,0x68, // config io port 68
	0x63,0x12,0x6c, // config io port 6c
	0x70,0x12,0x09, // select serirq num:9
	0x71,0x12,0x03, // set serirq level/edge
	0x30,0x12,0x01, // enable ld
#endif
#if SUPPORT_SHAREMEM_PNP
	/*LD:ShareMem*/
	0x07,0xf,0xf, // select sharemem
	//config firmware cycle 
	0xf0,0xf,0xfe,
	0xf1,0xf,0x00,
	0xf2,0xf,0x00,
	0xf4,0xf,0xf0,
	0xf5,0xf,0x00,
	0xf6,0xf,0x00,
	//Config SRAM offset map
	0x60,0xf,0x00,
	0x61,0xf,0x00,
	0xfa,0xf,0x00,	//config HOST Semaphore address
	0x30,0xf,0x01, 	// enable ld
#endif
#if 0
	/*LD:PMC3*/
	0x07,0x17,0x17,
	0x61,0x17,0x6a,
	0x63,0x17,0x6e,
	0x70,0x17,0x0f,
	0x71,0x17,0x01,
	0x30,0x17,0x01,
	/*LD:PMC4*/
	0x07,0x18,0x18,
	0x61,0x18,0x74,
	0x63,0x18,0x78,
	0x70,0x18,0x06,
	0x71,0x18,0x01,
	0x30,0x18,0x01,
	/*LD:PMC5*/
	0x07,0x19,0x19,
	0x61,0x19,0x7a,
	0x63,0x19,0x7c,
	0x70,0x19,0x08,
	0x71,0x19,0x01,
	0x30,0x19,0x01,
	/*LD:SWUC*/
	0x07,0x04,0x04,
	0x60,0x04,0x00,
	0x61,0x04,0x00,
	0x70,0x04,0x0f,
	0x71,0x04,0x01,
	0x30,0x04,0x00,
	/*LD:HWMONITOR*/
	0x07,0x03,0x03,
	0x60,0x03,0x00,
	0x61,0x03,0x05,
	0x70,0x03,0x0f,
	0x71,0x03,0x01,
	0x30,0x03,0x00,
	/*LD:UART0*/
	0x07,0x1b,0x1b,
	0x60,0x1b,0x03,
	0x61,0x1b,0xf8,
	0x70,0x1b,0x04,
	0x71,0x1b,0x01,
	0x30,0x1b,0x01,
	/*LD:UART1*/
	0x07,0x1c,0x1c,
	0x60,0x1c,0x02,
	0x61,0x1c,0xf8,
	0x70,0x1c,0x03,
	0x71,0x1c,0x01,
	0x30,0x1c,0x01,
	/*LD:UART2*/
	0x07,0x1d,0x1d,
	0x60,0x1d,0x00,
	0x61,0x1d,0xf8,
	0x70,0x1d,0x0a,
	0x71,0x1d,0x01,
	0x30,0x1d,0x01,
	/*LD:UART3*/
	0x07,0x1e,0x1e,
	0x60,0x1e,0x04,
	0x61,0x1e,0xf8,
	0x70,0x1e,0x0b,
	0x71,0x1e,0x01,
	0x30,0x1e,0x01,
	/*LD:UARTA*/
	0x07,0x01,0x01,
	0x60,0x01,0x05,
	0x61,0x01,0xf8,
	0x70,0x01,0x0f,
	0x71,0x01,0x01,
	0x30,0x01,0x01,
	/*LD:UARTB*/
	0x07,0x02,0x02,
	0x60,0x02,0x06,
	0x61,0x02,0xf8,
	0x70,0x02,0x0e,
	0x71,0x02,0x01,
	0x30,0x02,0x01,
	/*LD:CAN0*/
	0x07,0x15,0x15,
	0x60,0x15,0x10,
	0x61,0x15,0x00,
	0x70,0x15,0x0a,
	0x71,0x15,0x01,
	0x30,0x15,0x01,
	/*LD:CAN1*/
	0x07,0x16,0x16,
	0x60,0x16,0x20,
	0x61,0x16,0x00,
	0x70,0x16,0x0b,
	0x71,0x16,0x01,
	0x30,0x16,0x01,
	/*LD:CAN2*/
	0x07,0x1a,0x1a,
	0x60,0x1a,0x30,
	0x61,0x1a,0x00,
	0x70,0x1a,0x0d,
	0x71,0x1a,0x01,
	0x30,0x1a,0x01,
	/*LD:CAN3*/
	0x07,0x1f,0x1f,
	0x60,0x1f,0x40,
	0x61,0x1f,0x00,
	0x70,0x1f,0x0e,
	0x71,0x1f,0x01,
	0x30,0x1f,0x01,
	/*LD:SPIM*/
	0x07,0x13,0x13,
	0x60,0x13,0x00,
	0x61,0x13,0x00,
	0x70,0x13,0x10,
	0x71,0x13,0x01,
	0x30,0x13,0x01,
	/*LD:Parallel*/
	0x07,0x08,0x08,
	0x60,0x08,0x02,
	0x61,0x08,0x78,
	0x70,0x08,0x0f,
	0x71,0x08,0x01,
	0x30,0x08,0x01,
	#endif
};
void Sio_PNP_Config(void)
{
	BYTE *data_pntr;
	BYTE cnt = 0;
	data_pntr = Sio_PNP_Table;
	while(cnt < (sizeof(Sio_PNP_Table) / 3))
	{
		Config_PNP_Write(*(data_pntr + 3 * cnt + 0), *(data_pntr + 3 * cnt + 1), *(data_pntr + 3 * cnt + 2));
		cnt++;
	}
	dprint("Sio_PNP_Config finish\n");
}
//-----------------------------------------------------------------------------
// LogicalDevice PNP config function
//-----------------------------------------------------------------------------
void LogicalDevice_PNP_Config(void)
{
	h2e_MoudleClock_EN;
	// The Host's PNP device enable
	SYSCTL_HDEVEN = (HOST_UARTx_EN | HOST_KBC_PMC_EN | HOST_PP_EN | HOST_BRAM_P80_EN | HOST_SMFI_SSPI_EN | HOST_CANx_EN);
	// Send Request
	Config_PNP_Access_Request();
	// PNP Default Config
	Config_PNP_Write(0x23, 0x01, 0x01);
	// set other logical device irq to 0
	Clear_Logical_Device_Default_IRQ_Num();
	Sio_PNP_Config();
	Config_PNP_Access_Release();
	dprint("LogicalDevice PNP Config finish!\n");
}
//-----------------------------------------------------------------------------
// ShareMem PNP config function
//-----------------------------------------------------------------------------
void ShareMem_PNP_Config(void)
{
	h2e_MoudleClock_EN;
	sram_MoudleClock_EN;
	SYSCTL_HDEVEN |= HOST_SMFI_EN;
	SYSCTL_SPCTL0 |= PNPCNST_SETEN; //enable pnp const register//PNPKEY, PNPPORT, VENDORID, CHIPVER 的设置使
	SHAREMEMORY_INIT();
}
//-----------------------------------------------------------------------------
// Logical Device PNP config function
//-----------------------------------------------------------------------------
BYTE LD_PNP_Config(void)
{
#if SUPPORT_SHAREMEM_PNP
	ShareMem_PNP_Config();
#endif
#if SUPPORT_LD_PNP	
	LogicalDevice_PNP_Config();
#endif
	return 0;
}
